/**
 * This class file was automatically generated by jASN1 v1.10.0 (http://www.openmuc.org)
 */

package nr.rrc.definitions;

import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.io.Serializable;
import org.openmuc.jasn1.ber.*;
import org.openmuc.jasn1.ber.types.*;
import org.openmuc.jasn1.ber.types.string.*;


public class PDCPConfig implements BerType, Serializable {

	private static final long serialVersionUID = 1L;

	public static class Drb implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static class HeaderCompression implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public byte[] code = null;
			public static class Rohc implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class Profiles implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

					public byte[] code = null;
					private BerBoolean profile0x0001 = null;
					private BerBoolean profile0x0002 = null;
					private BerBoolean profile0x0003 = null;
					private BerBoolean profile0x0004 = null;
					private BerBoolean profile0x0006 = null;
					private BerBoolean profile0x0101 = null;
					private BerBoolean profile0x0102 = null;
					private BerBoolean profile0x0103 = null;
					private BerBoolean profile0x0104 = null;
					
					public Profiles() {
					}

					public Profiles(byte[] code) {
						this.code = code;
					}

					public void setProfile0x0001(BerBoolean profile0x0001) {
						this.profile0x0001 = profile0x0001;
					}

					public BerBoolean getProfile0x0001() {
						return profile0x0001;
					}

					public void setProfile0x0002(BerBoolean profile0x0002) {
						this.profile0x0002 = profile0x0002;
					}

					public BerBoolean getProfile0x0002() {
						return profile0x0002;
					}

					public void setProfile0x0003(BerBoolean profile0x0003) {
						this.profile0x0003 = profile0x0003;
					}

					public BerBoolean getProfile0x0003() {
						return profile0x0003;
					}

					public void setProfile0x0004(BerBoolean profile0x0004) {
						this.profile0x0004 = profile0x0004;
					}

					public BerBoolean getProfile0x0004() {
						return profile0x0004;
					}

					public void setProfile0x0006(BerBoolean profile0x0006) {
						this.profile0x0006 = profile0x0006;
					}

					public BerBoolean getProfile0x0006() {
						return profile0x0006;
					}

					public void setProfile0x0101(BerBoolean profile0x0101) {
						this.profile0x0101 = profile0x0101;
					}

					public BerBoolean getProfile0x0101() {
						return profile0x0101;
					}

					public void setProfile0x0102(BerBoolean profile0x0102) {
						this.profile0x0102 = profile0x0102;
					}

					public BerBoolean getProfile0x0102() {
						return profile0x0102;
					}

					public void setProfile0x0103(BerBoolean profile0x0103) {
						this.profile0x0103 = profile0x0103;
					}

					public BerBoolean getProfile0x0103() {
						return profile0x0103;
					}

					public void setProfile0x0104(BerBoolean profile0x0104) {
						this.profile0x0104 = profile0x0104;
					}

					public BerBoolean getProfile0x0104() {
						return profile0x0104;
					}

					public int encode(OutputStream reverseOS) throws IOException {
						return encode(reverseOS, true);
					}

					public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							if (withTag) {
								return tag.encode(reverseOS) + code.length;
							}
							return code.length;
						}

						int codeLength = 0;
						codeLength += profile0x0104.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 8
						reverseOS.write(0x88);
						codeLength += 1;
						
						codeLength += profile0x0103.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 7
						reverseOS.write(0x87);
						codeLength += 1;
						
						codeLength += profile0x0102.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 6
						reverseOS.write(0x86);
						codeLength += 1;
						
						codeLength += profile0x0101.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 5
						reverseOS.write(0x85);
						codeLength += 1;
						
						codeLength += profile0x0006.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 4
						reverseOS.write(0x84);
						codeLength += 1;
						
						codeLength += profile0x0004.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 3
						reverseOS.write(0x83);
						codeLength += 1;
						
						codeLength += profile0x0003.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 2
						reverseOS.write(0x82);
						codeLength += 1;
						
						codeLength += profile0x0002.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 1
						reverseOS.write(0x81);
						codeLength += 1;
						
						codeLength += profile0x0001.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 0
						reverseOS.write(0x80);
						codeLength += 1;
						
						codeLength += BerLength.encodeLength(reverseOS, codeLength);

						if (withTag) {
							codeLength += tag.encode(reverseOS);
						}

						return codeLength;

					}

					public int decode(InputStream is) throws IOException {
						return decode(is, true);
					}

					public int decode(InputStream is, boolean withTag) throws IOException {
						int codeLength = 0;
						int subCodeLength = 0;
						BerTag berTag = new BerTag();

						if (withTag) {
							codeLength += tag.decodeAndCheck(is);
						}

						BerLength length = new BerLength();
						codeLength += length.decode(is);

						int totalLength = length.val;
						codeLength += totalLength;

						subCodeLength += berTag.decode(is);
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							profile0x0001 = new BerBoolean();
							subCodeLength += profile0x0001.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
							profile0x0002 = new BerBoolean();
							subCodeLength += profile0x0002.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
							profile0x0003 = new BerBoolean();
							subCodeLength += profile0x0003.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 3)) {
							profile0x0004 = new BerBoolean();
							subCodeLength += profile0x0004.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 4)) {
							profile0x0006 = new BerBoolean();
							subCodeLength += profile0x0006.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 5)) {
							profile0x0101 = new BerBoolean();
							subCodeLength += profile0x0101.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 6)) {
							profile0x0102 = new BerBoolean();
							subCodeLength += profile0x0102.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 7)) {
							profile0x0103 = new BerBoolean();
							subCodeLength += profile0x0103.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 8)) {
							profile0x0104 = new BerBoolean();
							subCodeLength += profile0x0104.decode(is, false);
							if (subCodeLength == totalLength) {
								return codeLength;
							}
						}
						throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

						
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS, false);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						sb.append("{");
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0001 != null) {
							sb.append("profile0x0001: ").append(profile0x0001);
						}
						else {
							sb.append("profile0x0001: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0002 != null) {
							sb.append("profile0x0002: ").append(profile0x0002);
						}
						else {
							sb.append("profile0x0002: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0003 != null) {
							sb.append("profile0x0003: ").append(profile0x0003);
						}
						else {
							sb.append("profile0x0003: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0004 != null) {
							sb.append("profile0x0004: ").append(profile0x0004);
						}
						else {
							sb.append("profile0x0004: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0006 != null) {
							sb.append("profile0x0006: ").append(profile0x0006);
						}
						else {
							sb.append("profile0x0006: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0101 != null) {
							sb.append("profile0x0101: ").append(profile0x0101);
						}
						else {
							sb.append("profile0x0101: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0102 != null) {
							sb.append("profile0x0102: ").append(profile0x0102);
						}
						else {
							sb.append("profile0x0102: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0103 != null) {
							sb.append("profile0x0103: ").append(profile0x0103);
						}
						else {
							sb.append("profile0x0103: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0104 != null) {
							sb.append("profile0x0104: ").append(profile0x0104);
						}
						else {
							sb.append("profile0x0104: <empty-required-field>");
						}
						
						sb.append("\n");
						for (int i = 0; i < indentLevel; i++) {
							sb.append("\t");
						}
						sb.append("}");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger maxCID = null;
				private Profiles profiles = null;
				private BerEnum drbContinueROHC = null;
				
				public Rohc() {
				}

				public Rohc(byte[] code) {
					this.code = code;
				}

				public void setMaxCID(BerInteger maxCID) {
					this.maxCID = maxCID;
				}

				public BerInteger getMaxCID() {
					return maxCID;
				}

				public void setProfiles(Profiles profiles) {
					this.profiles = profiles;
				}

				public Profiles getProfiles() {
					return profiles;
				}

				public void setDrbContinueROHC(BerEnum drbContinueROHC) {
					this.drbContinueROHC = drbContinueROHC;
				}

				public BerEnum getDrbContinueROHC() {
					return drbContinueROHC;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					if (drbContinueROHC != null) {
						codeLength += drbContinueROHC.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 2
						reverseOS.write(0x82);
						codeLength += 1;
					}
					
					codeLength += profiles.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
					reverseOS.write(0xA1);
					codeLength += 1;
					
					if (maxCID != null) {
						codeLength += maxCID.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 0
						reverseOS.write(0x80);
						codeLength += 1;
					}
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
						maxCID = new BerInteger();
						subCodeLength += maxCID.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					
					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
						profiles = new Profiles();
						subCodeLength += profiles.decode(is, false);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
						drbContinueROHC = new BerEnum();
						subCodeLength += drbContinueROHC.decode(is, false);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					boolean firstSelectedElement = true;
					if (maxCID != null) {
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						sb.append("maxCID: ").append(maxCID);
						firstSelectedElement = false;
					}
					
					if (!firstSelectedElement) {
						sb.append(",\n");
					}
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (profiles != null) {
						sb.append("profiles: ");
						profiles.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("profiles: <empty-required-field>");
					}
					
					if (drbContinueROHC != null) {
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						sb.append("drbContinueROHC: ").append(drbContinueROHC);
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static class UplinkOnlyROHC implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class Profiles implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

					public byte[] code = null;
					private BerBoolean profile0x0006 = null;
					
					public Profiles() {
					}

					public Profiles(byte[] code) {
						this.code = code;
					}

					public void setProfile0x0006(BerBoolean profile0x0006) {
						this.profile0x0006 = profile0x0006;
					}

					public BerBoolean getProfile0x0006() {
						return profile0x0006;
					}

					public int encode(OutputStream reverseOS) throws IOException {
						return encode(reverseOS, true);
					}

					public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							if (withTag) {
								return tag.encode(reverseOS) + code.length;
							}
							return code.length;
						}

						int codeLength = 0;
						codeLength += profile0x0006.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 0
						reverseOS.write(0x80);
						codeLength += 1;
						
						codeLength += BerLength.encodeLength(reverseOS, codeLength);

						if (withTag) {
							codeLength += tag.encode(reverseOS);
						}

						return codeLength;

					}

					public int decode(InputStream is) throws IOException {
						return decode(is, true);
					}

					public int decode(InputStream is, boolean withTag) throws IOException {
						int codeLength = 0;
						int subCodeLength = 0;
						BerTag berTag = new BerTag();

						if (withTag) {
							codeLength += tag.decodeAndCheck(is);
						}

						BerLength length = new BerLength();
						codeLength += length.decode(is);

						int totalLength = length.val;
						codeLength += totalLength;

						subCodeLength += berTag.decode(is);
						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							profile0x0006 = new BerBoolean();
							subCodeLength += profile0x0006.decode(is, false);
							if (subCodeLength == totalLength) {
								return codeLength;
							}
						}
						throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

						
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS, false);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						sb.append("{");
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (profile0x0006 != null) {
							sb.append("profile0x0006: ").append(profile0x0006);
						}
						else {
							sb.append("profile0x0006: <empty-required-field>");
						}
						
						sb.append("\n");
						for (int i = 0; i < indentLevel; i++) {
							sb.append("\t");
						}
						sb.append("}");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger maxCID = null;
				private Profiles profiles = null;
				private BerEnum drbContinueROHC = null;
				
				public UplinkOnlyROHC() {
				}

				public UplinkOnlyROHC(byte[] code) {
					this.code = code;
				}

				public void setMaxCID(BerInteger maxCID) {
					this.maxCID = maxCID;
				}

				public BerInteger getMaxCID() {
					return maxCID;
				}

				public void setProfiles(Profiles profiles) {
					this.profiles = profiles;
				}

				public Profiles getProfiles() {
					return profiles;
				}

				public void setDrbContinueROHC(BerEnum drbContinueROHC) {
					this.drbContinueROHC = drbContinueROHC;
				}

				public BerEnum getDrbContinueROHC() {
					return drbContinueROHC;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					if (drbContinueROHC != null) {
						codeLength += drbContinueROHC.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 2
						reverseOS.write(0x82);
						codeLength += 1;
					}
					
					codeLength += profiles.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
					reverseOS.write(0xA1);
					codeLength += 1;
					
					if (maxCID != null) {
						codeLength += maxCID.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, PRIMITIVE, 0
						reverseOS.write(0x80);
						codeLength += 1;
					}
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
						maxCID = new BerInteger();
						subCodeLength += maxCID.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					
					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
						profiles = new Profiles();
						subCodeLength += profiles.decode(is, false);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
						drbContinueROHC = new BerEnum();
						subCodeLength += drbContinueROHC.decode(is, false);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					boolean firstSelectedElement = true;
					if (maxCID != null) {
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						sb.append("maxCID: ").append(maxCID);
						firstSelectedElement = false;
					}
					
					if (!firstSelectedElement) {
						sb.append(",\n");
					}
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (profiles != null) {
						sb.append("profiles: ");
						profiles.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("profiles: <empty-required-field>");
					}
					
					if (drbContinueROHC != null) {
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						sb.append("drbContinueROHC: ").append(drbContinueROHC);
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			private BerNull notUsed = null;
			private Rohc rohc = null;
			private UplinkOnlyROHC uplinkOnlyROHC = null;
			
			public HeaderCompression() {
			}

			public HeaderCompression(byte[] code) {
				this.code = code;
			}

			public void setNotUsed(BerNull notUsed) {
				this.notUsed = notUsed;
			}

			public BerNull getNotUsed() {
				return notUsed;
			}

			public void setRohc(Rohc rohc) {
				this.rohc = rohc;
			}

			public Rohc getRohc() {
				return rohc;
			}

			public void setUplinkOnlyROHC(UplinkOnlyROHC uplinkOnlyROHC) {
				this.uplinkOnlyROHC = uplinkOnlyROHC;
			}

			public UplinkOnlyROHC getUplinkOnlyROHC() {
				return uplinkOnlyROHC;
			}

			public int encode(OutputStream reverseOS) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					return code.length;
				}

				int codeLength = 0;
				if (uplinkOnlyROHC != null) {
					codeLength += uplinkOnlyROHC.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 2
					reverseOS.write(0xA2);
					codeLength += 1;
					return codeLength;
				}
				
				if (rohc != null) {
					codeLength += rohc.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
					reverseOS.write(0xA1);
					codeLength += 1;
					return codeLength;
				}
				
				if (notUsed != null) {
					codeLength += notUsed.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, PRIMITIVE, 0
					reverseOS.write(0x80);
					codeLength += 1;
					return codeLength;
				}
				
				throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
			}

			public int decode(InputStream is) throws IOException {
				return decode(is, null);
			}

			public int decode(InputStream is, BerTag berTag) throws IOException {

				int codeLength = 0;
				BerTag passedTag = berTag;

				if (berTag == null) {
					berTag = new BerTag();
					codeLength += berTag.decode(is);
				}

				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
					notUsed = new BerNull();
					codeLength += notUsed.decode(is, false);
					return codeLength;
				}

				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
					rohc = new Rohc();
					codeLength += rohc.decode(is, false);
					return codeLength;
				}

				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 2)) {
					uplinkOnlyROHC = new UplinkOnlyROHC();
					codeLength += uplinkOnlyROHC.decode(is, false);
					return codeLength;
				}

				if (passedTag != null) {
					return 0;
				}

				throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				if (notUsed != null) {
					sb.append("notUsed: ").append(notUsed);
					return;
				}

				if (rohc != null) {
					sb.append("rohc: ");
					rohc.appendAsString(sb, indentLevel + 1);
					return;
				}

				if (uplinkOnlyROHC != null) {
					sb.append("uplinkOnlyROHC: ");
					uplinkOnlyROHC.appendAsString(sb, indentLevel + 1);
					return;
				}

				sb.append("<none>");
			}

		}

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private BerEnum discardTimer = null;
		private BerEnum pdcpSNSizeUL = null;
		private BerEnum pdcpSNSizeDL = null;
		private HeaderCompression headerCompression = null;
		private BerEnum integrityProtection = null;
		private BerEnum statusReportRequired = null;
		private BerEnum outOfOrderDelivery = null;
		
		public Drb() {
		}

		public Drb(byte[] code) {
			this.code = code;
		}

		public void setDiscardTimer(BerEnum discardTimer) {
			this.discardTimer = discardTimer;
		}

		public BerEnum getDiscardTimer() {
			return discardTimer;
		}

		public void setPdcpSNSizeUL(BerEnum pdcpSNSizeUL) {
			this.pdcpSNSizeUL = pdcpSNSizeUL;
		}

		public BerEnum getPdcpSNSizeUL() {
			return pdcpSNSizeUL;
		}

		public void setPdcpSNSizeDL(BerEnum pdcpSNSizeDL) {
			this.pdcpSNSizeDL = pdcpSNSizeDL;
		}

		public BerEnum getPdcpSNSizeDL() {
			return pdcpSNSizeDL;
		}

		public void setHeaderCompression(HeaderCompression headerCompression) {
			this.headerCompression = headerCompression;
		}

		public HeaderCompression getHeaderCompression() {
			return headerCompression;
		}

		public void setIntegrityProtection(BerEnum integrityProtection) {
			this.integrityProtection = integrityProtection;
		}

		public BerEnum getIntegrityProtection() {
			return integrityProtection;
		}

		public void setStatusReportRequired(BerEnum statusReportRequired) {
			this.statusReportRequired = statusReportRequired;
		}

		public BerEnum getStatusReportRequired() {
			return statusReportRequired;
		}

		public void setOutOfOrderDelivery(BerEnum outOfOrderDelivery) {
			this.outOfOrderDelivery = outOfOrderDelivery;
		}

		public BerEnum getOutOfOrderDelivery() {
			return outOfOrderDelivery;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			int sublength;

			if (outOfOrderDelivery != null) {
				codeLength += outOfOrderDelivery.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 6
				reverseOS.write(0x86);
				codeLength += 1;
			}
			
			if (statusReportRequired != null) {
				codeLength += statusReportRequired.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 5
				reverseOS.write(0x85);
				codeLength += 1;
			}
			
			if (integrityProtection != null) {
				codeLength += integrityProtection.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 4
				reverseOS.write(0x84);
				codeLength += 1;
			}
			
			sublength = headerCompression.encode(reverseOS);
			codeLength += sublength;
			codeLength += BerLength.encodeLength(reverseOS, sublength);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 3
			reverseOS.write(0xA3);
			codeLength += 1;
			
			if (pdcpSNSizeDL != null) {
				codeLength += pdcpSNSizeDL.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 2
				reverseOS.write(0x82);
				codeLength += 1;
			}
			
			if (pdcpSNSizeUL != null) {
				codeLength += pdcpSNSizeUL.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 1
				reverseOS.write(0x81);
				codeLength += 1;
			}
			
			if (discardTimer != null) {
				codeLength += discardTimer.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 0
				reverseOS.write(0x80);
				codeLength += 1;
			}
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
				discardTimer = new BerEnum();
				subCodeLength += discardTimer.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
				pdcpSNSizeUL = new BerEnum();
				subCodeLength += pdcpSNSizeUL.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
				pdcpSNSizeDL = new BerEnum();
				subCodeLength += pdcpSNSizeDL.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 3)) {
				subCodeLength += length.decode(is);
				headerCompression = new HeaderCompression();
				subCodeLength += headerCompression.decode(is, null);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 4)) {
				integrityProtection = new BerEnum();
				subCodeLength += integrityProtection.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 5)) {
				statusReportRequired = new BerEnum();
				subCodeLength += statusReportRequired.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 6)) {
				outOfOrderDelivery = new BerEnum();
				subCodeLength += outOfOrderDelivery.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			boolean firstSelectedElement = true;
			if (discardTimer != null) {
				sb.append("\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("discardTimer: ").append(discardTimer);
				firstSelectedElement = false;
			}
			
			if (pdcpSNSizeUL != null) {
				if (!firstSelectedElement) {
					sb.append(",\n");
				}
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("pdcpSNSizeUL: ").append(pdcpSNSizeUL);
				firstSelectedElement = false;
			}
			
			if (pdcpSNSizeDL != null) {
				if (!firstSelectedElement) {
					sb.append(",\n");
				}
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("pdcpSNSizeDL: ").append(pdcpSNSizeDL);
				firstSelectedElement = false;
			}
			
			if (!firstSelectedElement) {
				sb.append(",\n");
			}
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (headerCompression != null) {
				sb.append("headerCompression: ");
				headerCompression.appendAsString(sb, indentLevel + 1);
			}
			else {
				sb.append("headerCompression: <empty-required-field>");
			}
			
			if (integrityProtection != null) {
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("integrityProtection: ").append(integrityProtection);
			}
			
			if (statusReportRequired != null) {
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("statusReportRequired: ").append(statusReportRequired);
			}
			
			if (outOfOrderDelivery != null) {
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("outOfOrderDelivery: ").append(outOfOrderDelivery);
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class MoreThanOneRLC implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static class PrimaryPath implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			private CellGroupId cellGroup = null;
			private LogicalChannelIdentity logicalChannel = null;
			
			public PrimaryPath() {
			}

			public PrimaryPath(byte[] code) {
				this.code = code;
			}

			public void setCellGroup(CellGroupId cellGroup) {
				this.cellGroup = cellGroup;
			}

			public CellGroupId getCellGroup() {
				return cellGroup;
			}

			public void setLogicalChannel(LogicalChannelIdentity logicalChannel) {
				this.logicalChannel = logicalChannel;
			}

			public LogicalChannelIdentity getLogicalChannel() {
				return logicalChannel;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				if (logicalChannel != null) {
					codeLength += logicalChannel.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, PRIMITIVE, 1
					reverseOS.write(0x81);
					codeLength += 1;
				}
				
				if (cellGroup != null) {
					codeLength += cellGroup.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, PRIMITIVE, 0
					reverseOS.write(0x80);
					codeLength += 1;
				}
				
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				if (totalLength == 0) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
					cellGroup = new CellGroupId();
					subCodeLength += cellGroup.decode(is, false);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					subCodeLength += berTag.decode(is);
				}
				
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
					logicalChannel = new LogicalChannelIdentity();
					subCodeLength += logicalChannel.decode(is, false);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
				}
				throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

				
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				boolean firstSelectedElement = true;
				if (cellGroup != null) {
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					sb.append("cellGroup: ").append(cellGroup);
					firstSelectedElement = false;
				}
				
				if (logicalChannel != null) {
					if (!firstSelectedElement) {
						sb.append(",\n");
					}
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					sb.append("logicalChannel: ").append(logicalChannel);
					firstSelectedElement = false;
				}
				
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private PrimaryPath primaryPath = null;
		private ULDataSplitThreshold ulDataSplitThreshold = null;
		private BerBoolean pdcpDuplication = null;
		
		public MoreThanOneRLC() {
		}

		public MoreThanOneRLC(byte[] code) {
			this.code = code;
		}

		public void setPrimaryPath(PrimaryPath primaryPath) {
			this.primaryPath = primaryPath;
		}

		public PrimaryPath getPrimaryPath() {
			return primaryPath;
		}

		public void setUlDataSplitThreshold(ULDataSplitThreshold ulDataSplitThreshold) {
			this.ulDataSplitThreshold = ulDataSplitThreshold;
		}

		public ULDataSplitThreshold getUlDataSplitThreshold() {
			return ulDataSplitThreshold;
		}

		public void setPdcpDuplication(BerBoolean pdcpDuplication) {
			this.pdcpDuplication = pdcpDuplication;
		}

		public BerBoolean getPdcpDuplication() {
			return pdcpDuplication;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			if (pdcpDuplication != null) {
				codeLength += pdcpDuplication.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 2
				reverseOS.write(0x82);
				codeLength += 1;
			}
			
			if (ulDataSplitThreshold != null) {
				codeLength += ulDataSplitThreshold.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 1
				reverseOS.write(0x81);
				codeLength += 1;
			}
			
			codeLength += primaryPath.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
			reverseOS.write(0xA0);
			codeLength += 1;
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
				primaryPath = new PrimaryPath();
				subCodeLength += primaryPath.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
				ulDataSplitThreshold = new ULDataSplitThreshold();
				subCodeLength += ulDataSplitThreshold.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
				pdcpDuplication = new BerBoolean();
				subCodeLength += pdcpDuplication.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (primaryPath != null) {
				sb.append("primaryPath: ");
				primaryPath.appendAsString(sb, indentLevel + 1);
			}
			else {
				sb.append("primaryPath: <empty-required-field>");
			}
			
			if (ulDataSplitThreshold != null) {
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("ulDataSplitThreshold: ").append(ulDataSplitThreshold);
			}
			
			if (pdcpDuplication != null) {
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				sb.append("pdcpDuplication: ").append(pdcpDuplication);
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

	public byte[] code = null;
	private Drb drb = null;
	private MoreThanOneRLC moreThanOneRLC = null;
	private BerEnum tReordering = null;
	
	public PDCPConfig() {
	}

	public PDCPConfig(byte[] code) {
		this.code = code;
	}

	public void setDrb(Drb drb) {
		this.drb = drb;
	}

	public Drb getDrb() {
		return drb;
	}

	public void setMoreThanOneRLC(MoreThanOneRLC moreThanOneRLC) {
		this.moreThanOneRLC = moreThanOneRLC;
	}

	public MoreThanOneRLC getMoreThanOneRLC() {
		return moreThanOneRLC;
	}

	public void setTReordering(BerEnum tReordering) {
		this.tReordering = tReordering;
	}

	public BerEnum getTReordering() {
		return tReordering;
	}

	public int encode(OutputStream reverseOS) throws IOException {
		return encode(reverseOS, true);
	}

	public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

		if (code != null) {
			for (int i = code.length - 1; i >= 0; i--) {
				reverseOS.write(code[i]);
			}
			if (withTag) {
				return tag.encode(reverseOS) + code.length;
			}
			return code.length;
		}

		int codeLength = 0;
		if (tReordering != null) {
			codeLength += tReordering.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 2
			reverseOS.write(0x82);
			codeLength += 1;
		}
		
		if (moreThanOneRLC != null) {
			codeLength += moreThanOneRLC.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
			reverseOS.write(0xA1);
			codeLength += 1;
		}
		
		if (drb != null) {
			codeLength += drb.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
			reverseOS.write(0xA0);
			codeLength += 1;
		}
		
		codeLength += BerLength.encodeLength(reverseOS, codeLength);

		if (withTag) {
			codeLength += tag.encode(reverseOS);
		}

		return codeLength;

	}

	public int decode(InputStream is) throws IOException {
		return decode(is, true);
	}

	public int decode(InputStream is, boolean withTag) throws IOException {
		int codeLength = 0;
		int subCodeLength = 0;
		BerTag berTag = new BerTag();

		if (withTag) {
			codeLength += tag.decodeAndCheck(is);
		}

		BerLength length = new BerLength();
		codeLength += length.decode(is);

		int totalLength = length.val;
		codeLength += totalLength;

		if (totalLength == 0) {
			return codeLength;
		}
		subCodeLength += berTag.decode(is);
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
			drb = new Drb();
			subCodeLength += drb.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
			moreThanOneRLC = new MoreThanOneRLC();
			subCodeLength += moreThanOneRLC.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
			tReordering = new BerEnum();
			subCodeLength += tReordering.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
		}
		throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

		
	}

	public void encodeAndSave(int encodingSizeGuess) throws IOException {
		ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
		encode(reverseOS, false);
		code = reverseOS.getArray();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		appendAsString(sb, 0);
		return sb.toString();
	}

	public void appendAsString(StringBuilder sb, int indentLevel) {

		sb.append("{");
		boolean firstSelectedElement = true;
		if (drb != null) {
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("drb: ");
			drb.appendAsString(sb, indentLevel + 1);
			firstSelectedElement = false;
		}
		
		if (moreThanOneRLC != null) {
			if (!firstSelectedElement) {
				sb.append(",\n");
			}
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("moreThanOneRLC: ");
			moreThanOneRLC.appendAsString(sb, indentLevel + 1);
			firstSelectedElement = false;
		}
		
		if (tReordering != null) {
			if (!firstSelectedElement) {
				sb.append(",\n");
			}
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("tReordering: ").append(tReordering);
			firstSelectedElement = false;
		}
		
		sb.append("\n");
		for (int i = 0; i < indentLevel; i++) {
			sb.append("\t");
		}
		sb.append("}");
	}

}

