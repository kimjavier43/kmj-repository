/**
 * This class file was automatically generated by jASN1 v1.10.0 (http://www.openmuc.org)
 */

package nr.rrc.definitions;

import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.io.Serializable;
import org.openmuc.jasn1.ber.*;
import org.openmuc.jasn1.ber.types.*;
import org.openmuc.jasn1.ber.types.string.*;


public class ControlResourceSet implements BerType, Serializable {

	private static final long serialVersionUID = 1L;

	public static class CceREGMappingType implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public byte[] code = null;
		public static class Interleaved implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			private BerEnum regBundleSize = null;
			private BerEnum interleaverSize = null;
			private BerInteger shiftIndex = null;
			
			public Interleaved() {
			}

			public Interleaved(byte[] code) {
				this.code = code;
			}

			public void setRegBundleSize(BerEnum regBundleSize) {
				this.regBundleSize = regBundleSize;
			}

			public BerEnum getRegBundleSize() {
				return regBundleSize;
			}

			public void setInterleaverSize(BerEnum interleaverSize) {
				this.interleaverSize = interleaverSize;
			}

			public BerEnum getInterleaverSize() {
				return interleaverSize;
			}

			public void setShiftIndex(BerInteger shiftIndex) {
				this.shiftIndex = shiftIndex;
			}

			public BerInteger getShiftIndex() {
				return shiftIndex;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				if (shiftIndex != null) {
					codeLength += shiftIndex.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, PRIMITIVE, 2
					reverseOS.write(0x82);
					codeLength += 1;
				}
				
				codeLength += interleaverSize.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 1
				reverseOS.write(0x81);
				codeLength += 1;
				
				codeLength += regBundleSize.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 0
				reverseOS.write(0x80);
				codeLength += 1;
				
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				subCodeLength += berTag.decode(is);
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
					regBundleSize = new BerEnum();
					subCodeLength += regBundleSize.decode(is, false);
					subCodeLength += berTag.decode(is);
				}
				else {
					throw new IOException("Tag does not match the mandatory sequence element tag.");
				}
				
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
					interleaverSize = new BerEnum();
					subCodeLength += interleaverSize.decode(is, false);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					subCodeLength += berTag.decode(is);
				}
				else {
					throw new IOException("Tag does not match the mandatory sequence element tag.");
				}
				
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
					shiftIndex = new BerInteger();
					subCodeLength += shiftIndex.decode(is, false);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
				}
				throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

				
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				sb.append("\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (regBundleSize != null) {
					sb.append("regBundleSize: ").append(regBundleSize);
				}
				else {
					sb.append("regBundleSize: <empty-required-field>");
				}
				
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (interleaverSize != null) {
					sb.append("interleaverSize: ").append(interleaverSize);
				}
				else {
					sb.append("interleaverSize: <empty-required-field>");
				}
				
				if (shiftIndex != null) {
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					sb.append("shiftIndex: ").append(shiftIndex);
				}
				
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		private Interleaved interleaved = null;
		private BerNull nonInterleaved = null;
		
		public CceREGMappingType() {
		}

		public CceREGMappingType(byte[] code) {
			this.code = code;
		}

		public void setInterleaved(Interleaved interleaved) {
			this.interleaved = interleaved;
		}

		public Interleaved getInterleaved() {
			return interleaved;
		}

		public void setNonInterleaved(BerNull nonInterleaved) {
			this.nonInterleaved = nonInterleaved;
		}

		public BerNull getNonInterleaved() {
			return nonInterleaved;
		}

		public int encode(OutputStream reverseOS) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				return code.length;
			}

			int codeLength = 0;
			if (nonInterleaved != null) {
				codeLength += nonInterleaved.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 1
				reverseOS.write(0x81);
				codeLength += 1;
				return codeLength;
			}
			
			if (interleaved != null) {
				codeLength += interleaved.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
				reverseOS.write(0xA0);
				codeLength += 1;
				return codeLength;
			}
			
			throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
		}

		public int decode(InputStream is) throws IOException {
			return decode(is, null);
		}

		public int decode(InputStream is, BerTag berTag) throws IOException {

			int codeLength = 0;
			BerTag passedTag = berTag;

			if (berTag == null) {
				berTag = new BerTag();
				codeLength += berTag.decode(is);
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
				interleaved = new Interleaved();
				codeLength += interleaved.decode(is, false);
				return codeLength;
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
				nonInterleaved = new BerNull();
				codeLength += nonInterleaved.decode(is, false);
				return codeLength;
			}

			if (passedTag != null) {
				return 0;
			}

			throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			if (interleaved != null) {
				sb.append("interleaved: ");
				interleaved.appendAsString(sb, indentLevel + 1);
				return;
			}

			if (nonInterleaved != null) {
				sb.append("nonInterleaved: ").append(nonInterleaved);
				return;
			}

			sb.append("<none>");
		}

	}

	public static class TciStatesPDCCHToAddList implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
		public byte[] code = null;
		private List<TCIStateId> seqOf = null;

		public TciStatesPDCCHToAddList() {
			seqOf = new ArrayList<TCIStateId>();
		}

		public TciStatesPDCCHToAddList(byte[] code) {
			this.code = code;
		}

		public List<TCIStateId> getTCIStateId() {
			if (seqOf == null) {
				seqOf = new ArrayList<TCIStateId>();
			}
			return seqOf;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			for (int i = (seqOf.size() - 1); i >= 0; i--) {
				codeLength += seqOf.get(i).encode(reverseOS, true);
			}

			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;
		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);
			int totalLength = length.val;

			while (subCodeLength < totalLength) {
				TCIStateId element = new TCIStateId();
				subCodeLength += element.decode(is, true);
				seqOf.add(element);
			}
			if (subCodeLength != totalLength) {
				throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

			}
			codeLength += subCodeLength;

			return codeLength;
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (seqOf == null) {
				sb.append("null");
			}
			else {
				Iterator<TCIStateId> it = seqOf.iterator();
				if (it.hasNext()) {
					sb.append(it.next());
					while (it.hasNext()) {
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						sb.append(it.next());
					}
				}
			}

			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class TciStatesPDCCHToReleaseList implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
		public byte[] code = null;
		private List<TCIStateId> seqOf = null;

		public TciStatesPDCCHToReleaseList() {
			seqOf = new ArrayList<TCIStateId>();
		}

		public TciStatesPDCCHToReleaseList(byte[] code) {
			this.code = code;
		}

		public List<TCIStateId> getTCIStateId() {
			if (seqOf == null) {
				seqOf = new ArrayList<TCIStateId>();
			}
			return seqOf;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			for (int i = (seqOf.size() - 1); i >= 0; i--) {
				codeLength += seqOf.get(i).encode(reverseOS, true);
			}

			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;
		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);
			int totalLength = length.val;

			while (subCodeLength < totalLength) {
				TCIStateId element = new TCIStateId();
				subCodeLength += element.decode(is, true);
				seqOf.add(element);
			}
			if (subCodeLength != totalLength) {
				throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

			}
			codeLength += subCodeLength;

			return codeLength;
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (seqOf == null) {
				sb.append("null");
			}
			else {
				Iterator<TCIStateId> it = seqOf.iterator();
				if (it.hasNext()) {
					sb.append(it.next());
					while (it.hasNext()) {
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						sb.append(it.next());
					}
				}
			}

			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

	public byte[] code = null;
	private ControlResourceSetId controlResourceSetId = null;
	private BerBitString frequencyDomainResources = null;
	private BerInteger duration = null;
	private CceREGMappingType cceREGMappingType = null;
	private BerEnum precoderGranularity = null;
	private TciStatesPDCCHToAddList tciStatesPDCCHToAddList = null;
	private TciStatesPDCCHToReleaseList tciStatesPDCCHToReleaseList = null;
	private BerEnum tciPresentInDCI = null;
	private BerInteger pdcchDMRSScramblingID = null;
	
	public ControlResourceSet() {
	}

	public ControlResourceSet(byte[] code) {
		this.code = code;
	}

	public void setControlResourceSetId(ControlResourceSetId controlResourceSetId) {
		this.controlResourceSetId = controlResourceSetId;
	}

	public ControlResourceSetId getControlResourceSetId() {
		return controlResourceSetId;
	}

	public void setFrequencyDomainResources(BerBitString frequencyDomainResources) {
		this.frequencyDomainResources = frequencyDomainResources;
	}

	public BerBitString getFrequencyDomainResources() {
		return frequencyDomainResources;
	}

	public void setDuration(BerInteger duration) {
		this.duration = duration;
	}

	public BerInteger getDuration() {
		return duration;
	}

	public void setCceREGMappingType(CceREGMappingType cceREGMappingType) {
		this.cceREGMappingType = cceREGMappingType;
	}

	public CceREGMappingType getCceREGMappingType() {
		return cceREGMappingType;
	}

	public void setPrecoderGranularity(BerEnum precoderGranularity) {
		this.precoderGranularity = precoderGranularity;
	}

	public BerEnum getPrecoderGranularity() {
		return precoderGranularity;
	}

	public void setTciStatesPDCCHToAddList(TciStatesPDCCHToAddList tciStatesPDCCHToAddList) {
		this.tciStatesPDCCHToAddList = tciStatesPDCCHToAddList;
	}

	public TciStatesPDCCHToAddList getTciStatesPDCCHToAddList() {
		return tciStatesPDCCHToAddList;
	}

	public void setTciStatesPDCCHToReleaseList(TciStatesPDCCHToReleaseList tciStatesPDCCHToReleaseList) {
		this.tciStatesPDCCHToReleaseList = tciStatesPDCCHToReleaseList;
	}

	public TciStatesPDCCHToReleaseList getTciStatesPDCCHToReleaseList() {
		return tciStatesPDCCHToReleaseList;
	}

	public void setTciPresentInDCI(BerEnum tciPresentInDCI) {
		this.tciPresentInDCI = tciPresentInDCI;
	}

	public BerEnum getTciPresentInDCI() {
		return tciPresentInDCI;
	}

	public void setPdcchDMRSScramblingID(BerInteger pdcchDMRSScramblingID) {
		this.pdcchDMRSScramblingID = pdcchDMRSScramblingID;
	}

	public BerInteger getPdcchDMRSScramblingID() {
		return pdcchDMRSScramblingID;
	}

	public int encode(OutputStream reverseOS) throws IOException {
		return encode(reverseOS, true);
	}

	public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

		if (code != null) {
			for (int i = code.length - 1; i >= 0; i--) {
				reverseOS.write(code[i]);
			}
			if (withTag) {
				return tag.encode(reverseOS) + code.length;
			}
			return code.length;
		}

		int codeLength = 0;
		int sublength;

		if (pdcchDMRSScramblingID != null) {
			codeLength += pdcchDMRSScramblingID.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 8
			reverseOS.write(0x88);
			codeLength += 1;
		}
		
		if (tciPresentInDCI != null) {
			codeLength += tciPresentInDCI.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 7
			reverseOS.write(0x87);
			codeLength += 1;
		}
		
		if (tciStatesPDCCHToReleaseList != null) {
			codeLength += tciStatesPDCCHToReleaseList.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 6
			reverseOS.write(0xA6);
			codeLength += 1;
		}
		
		if (tciStatesPDCCHToAddList != null) {
			codeLength += tciStatesPDCCHToAddList.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 5
			reverseOS.write(0xA5);
			codeLength += 1;
		}
		
		codeLength += precoderGranularity.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 4
		reverseOS.write(0x84);
		codeLength += 1;
		
		sublength = cceREGMappingType.encode(reverseOS);
		codeLength += sublength;
		codeLength += BerLength.encodeLength(reverseOS, sublength);
		// write tag: CONTEXT_CLASS, CONSTRUCTED, 3
		reverseOS.write(0xA3);
		codeLength += 1;
		
		codeLength += duration.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 2
		reverseOS.write(0x82);
		codeLength += 1;
		
		codeLength += frequencyDomainResources.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 1
		reverseOS.write(0x81);
		codeLength += 1;
		
		codeLength += controlResourceSetId.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 0
		reverseOS.write(0x80);
		codeLength += 1;
		
		codeLength += BerLength.encodeLength(reverseOS, codeLength);

		if (withTag) {
			codeLength += tag.encode(reverseOS);
		}

		return codeLength;

	}

	public int decode(InputStream is) throws IOException {
		return decode(is, true);
	}

	public int decode(InputStream is, boolean withTag) throws IOException {
		int codeLength = 0;
		int subCodeLength = 0;
		BerTag berTag = new BerTag();

		if (withTag) {
			codeLength += tag.decodeAndCheck(is);
		}

		BerLength length = new BerLength();
		codeLength += length.decode(is);

		int totalLength = length.val;
		codeLength += totalLength;

		subCodeLength += berTag.decode(is);
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
			controlResourceSetId = new ControlResourceSetId();
			subCodeLength += controlResourceSetId.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
			frequencyDomainResources = new BerBitString();
			subCodeLength += frequencyDomainResources.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
			duration = new BerInteger();
			subCodeLength += duration.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 3)) {
			subCodeLength += length.decode(is);
			cceREGMappingType = new CceREGMappingType();
			subCodeLength += cceREGMappingType.decode(is, null);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 4)) {
			precoderGranularity = new BerEnum();
			subCodeLength += precoderGranularity.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 5)) {
			tciStatesPDCCHToAddList = new TciStatesPDCCHToAddList();
			subCodeLength += tciStatesPDCCHToAddList.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 6)) {
			tciStatesPDCCHToReleaseList = new TciStatesPDCCHToReleaseList();
			subCodeLength += tciStatesPDCCHToReleaseList.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 7)) {
			tciPresentInDCI = new BerEnum();
			subCodeLength += tciPresentInDCI.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 8)) {
			pdcchDMRSScramblingID = new BerInteger();
			subCodeLength += pdcchDMRSScramblingID.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
		}
		throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

		
	}

	public void encodeAndSave(int encodingSizeGuess) throws IOException {
		ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
		encode(reverseOS, false);
		code = reverseOS.getArray();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		appendAsString(sb, 0);
		return sb.toString();
	}

	public void appendAsString(StringBuilder sb, int indentLevel) {

		sb.append("{");
		sb.append("\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (controlResourceSetId != null) {
			sb.append("controlResourceSetId: ").append(controlResourceSetId);
		}
		else {
			sb.append("controlResourceSetId: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (frequencyDomainResources != null) {
			sb.append("frequencyDomainResources: ").append(frequencyDomainResources);
		}
		else {
			sb.append("frequencyDomainResources: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (duration != null) {
			sb.append("duration: ").append(duration);
		}
		else {
			sb.append("duration: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (cceREGMappingType != null) {
			sb.append("cceREGMappingType: ");
			cceREGMappingType.appendAsString(sb, indentLevel + 1);
		}
		else {
			sb.append("cceREGMappingType: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (precoderGranularity != null) {
			sb.append("precoderGranularity: ").append(precoderGranularity);
		}
		else {
			sb.append("precoderGranularity: <empty-required-field>");
		}
		
		if (tciStatesPDCCHToAddList != null) {
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("tciStatesPDCCHToAddList: ");
			tciStatesPDCCHToAddList.appendAsString(sb, indentLevel + 1);
		}
		
		if (tciStatesPDCCHToReleaseList != null) {
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("tciStatesPDCCHToReleaseList: ");
			tciStatesPDCCHToReleaseList.appendAsString(sb, indentLevel + 1);
		}
		
		if (tciPresentInDCI != null) {
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("tciPresentInDCI: ").append(tciPresentInDCI);
		}
		
		if (pdcchDMRSScramblingID != null) {
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("pdcchDMRSScramblingID: ").append(pdcchDMRSScramblingID);
		}
		
		sb.append("\n");
		for (int i = 0; i < indentLevel; i++) {
			sb.append("\t");
		}
		sb.append("}");
	}

}

