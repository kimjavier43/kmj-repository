/**
 * This class file was automatically generated by jASN1 v1.10.0 (http://www.openmuc.org)
 */

package nr.rrc.definitions;

import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.io.Serializable;
import org.openmuc.jasn1.ber.*;
import org.openmuc.jasn1.ber.types.*;
import org.openmuc.jasn1.ber.types.string.*;


public class SRSResource implements BerType, Serializable {

	private static final long serialVersionUID = 1L;

	public static class TransmissionComb implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public byte[] code = null;
		public static class N2 implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			private BerInteger combOffsetN2 = null;
			private BerInteger cyclicShiftN2 = null;
			
			public N2() {
			}

			public N2(byte[] code) {
				this.code = code;
			}

			public void setCombOffsetN2(BerInteger combOffsetN2) {
				this.combOffsetN2 = combOffsetN2;
			}

			public BerInteger getCombOffsetN2() {
				return combOffsetN2;
			}

			public void setCyclicShiftN2(BerInteger cyclicShiftN2) {
				this.cyclicShiftN2 = cyclicShiftN2;
			}

			public BerInteger getCyclicShiftN2() {
				return cyclicShiftN2;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				codeLength += cyclicShiftN2.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 1
				reverseOS.write(0x81);
				codeLength += 1;
				
				codeLength += combOffsetN2.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 0
				reverseOS.write(0x80);
				codeLength += 1;
				
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				subCodeLength += berTag.decode(is);
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
					combOffsetN2 = new BerInteger();
					subCodeLength += combOffsetN2.decode(is, false);
					subCodeLength += berTag.decode(is);
				}
				else {
					throw new IOException("Tag does not match the mandatory sequence element tag.");
				}
				
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
					cyclicShiftN2 = new BerInteger();
					subCodeLength += cyclicShiftN2.decode(is, false);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
				}
				throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

				
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				sb.append("\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (combOffsetN2 != null) {
					sb.append("combOffsetN2: ").append(combOffsetN2);
				}
				else {
					sb.append("combOffsetN2: <empty-required-field>");
				}
				
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (cyclicShiftN2 != null) {
					sb.append("cyclicShiftN2: ").append(cyclicShiftN2);
				}
				else {
					sb.append("cyclicShiftN2: <empty-required-field>");
				}
				
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		public static class N4 implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			private BerInteger combOffsetN4 = null;
			private BerInteger cyclicShiftN4 = null;
			
			public N4() {
			}

			public N4(byte[] code) {
				this.code = code;
			}

			public void setCombOffsetN4(BerInteger combOffsetN4) {
				this.combOffsetN4 = combOffsetN4;
			}

			public BerInteger getCombOffsetN4() {
				return combOffsetN4;
			}

			public void setCyclicShiftN4(BerInteger cyclicShiftN4) {
				this.cyclicShiftN4 = cyclicShiftN4;
			}

			public BerInteger getCyclicShiftN4() {
				return cyclicShiftN4;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				codeLength += cyclicShiftN4.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 1
				reverseOS.write(0x81);
				codeLength += 1;
				
				codeLength += combOffsetN4.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, PRIMITIVE, 0
				reverseOS.write(0x80);
				codeLength += 1;
				
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				subCodeLength += berTag.decode(is);
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
					combOffsetN4 = new BerInteger();
					subCodeLength += combOffsetN4.decode(is, false);
					subCodeLength += berTag.decode(is);
				}
				else {
					throw new IOException("Tag does not match the mandatory sequence element tag.");
				}
				
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
					cyclicShiftN4 = new BerInteger();
					subCodeLength += cyclicShiftN4.decode(is, false);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
				}
				throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

				
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				sb.append("\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (combOffsetN4 != null) {
					sb.append("combOffsetN4: ").append(combOffsetN4);
				}
				else {
					sb.append("combOffsetN4: <empty-required-field>");
				}
				
				sb.append(",\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (cyclicShiftN4 != null) {
					sb.append("cyclicShiftN4: ").append(cyclicShiftN4);
				}
				else {
					sb.append("cyclicShiftN4: <empty-required-field>");
				}
				
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		private N2 n2 = null;
		private N4 n4 = null;
		
		public TransmissionComb() {
		}

		public TransmissionComb(byte[] code) {
			this.code = code;
		}

		public void setN2(N2 n2) {
			this.n2 = n2;
		}

		public N2 getN2() {
			return n2;
		}

		public void setN4(N4 n4) {
			this.n4 = n4;
		}

		public N4 getN4() {
			return n4;
		}

		public int encode(OutputStream reverseOS) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				return code.length;
			}

			int codeLength = 0;
			if (n4 != null) {
				codeLength += n4.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
				reverseOS.write(0xA1);
				codeLength += 1;
				return codeLength;
			}
			
			if (n2 != null) {
				codeLength += n2.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
				reverseOS.write(0xA0);
				codeLength += 1;
				return codeLength;
			}
			
			throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
		}

		public int decode(InputStream is) throws IOException {
			return decode(is, null);
		}

		public int decode(InputStream is, BerTag berTag) throws IOException {

			int codeLength = 0;
			BerTag passedTag = berTag;

			if (berTag == null) {
				berTag = new BerTag();
				codeLength += berTag.decode(is);
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
				n2 = new N2();
				codeLength += n2.decode(is, false);
				return codeLength;
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
				n4 = new N4();
				codeLength += n4.decode(is, false);
				return codeLength;
			}

			if (passedTag != null) {
				return 0;
			}

			throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			if (n2 != null) {
				sb.append("n2: ");
				n2.appendAsString(sb, indentLevel + 1);
				return;
			}

			if (n4 != null) {
				sb.append("n4: ");
				n4.appendAsString(sb, indentLevel + 1);
				return;
			}

			sb.append("<none>");
		}

	}

	public static class ResourceMapping implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private BerInteger startPosition = null;
		private BerEnum nrofSymbols = null;
		private BerEnum repetitionFactor = null;
		
		public ResourceMapping() {
		}

		public ResourceMapping(byte[] code) {
			this.code = code;
		}

		public void setStartPosition(BerInteger startPosition) {
			this.startPosition = startPosition;
		}

		public BerInteger getStartPosition() {
			return startPosition;
		}

		public void setNrofSymbols(BerEnum nrofSymbols) {
			this.nrofSymbols = nrofSymbols;
		}

		public BerEnum getNrofSymbols() {
			return nrofSymbols;
		}

		public void setRepetitionFactor(BerEnum repetitionFactor) {
			this.repetitionFactor = repetitionFactor;
		}

		public BerEnum getRepetitionFactor() {
			return repetitionFactor;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += repetitionFactor.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 2
			reverseOS.write(0x82);
			codeLength += 1;
			
			codeLength += nrofSymbols.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 1
			reverseOS.write(0x81);
			codeLength += 1;
			
			codeLength += startPosition.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 0
			reverseOS.write(0x80);
			codeLength += 1;
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
				startPosition = new BerInteger();
				subCodeLength += startPosition.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
				nrofSymbols = new BerEnum();
				subCodeLength += nrofSymbols.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
				repetitionFactor = new BerEnum();
				subCodeLength += repetitionFactor.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (startPosition != null) {
				sb.append("startPosition: ").append(startPosition);
			}
			else {
				sb.append("startPosition: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (nrofSymbols != null) {
				sb.append("nrofSymbols: ").append(nrofSymbols);
			}
			else {
				sb.append("nrofSymbols: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (repetitionFactor != null) {
				sb.append("repetitionFactor: ").append(repetitionFactor);
			}
			else {
				sb.append("repetitionFactor: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class FreqHopping implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private BerInteger cSRS = null;
		private BerInteger bSRS = null;
		private BerInteger bHop = null;
		
		public FreqHopping() {
		}

		public FreqHopping(byte[] code) {
			this.code = code;
		}

		public void setCSRS(BerInteger cSRS) {
			this.cSRS = cSRS;
		}

		public BerInteger getCSRS() {
			return cSRS;
		}

		public void setBSRS(BerInteger bSRS) {
			this.bSRS = bSRS;
		}

		public BerInteger getBSRS() {
			return bSRS;
		}

		public void setBHop(BerInteger bHop) {
			this.bHop = bHop;
		}

		public BerInteger getBHop() {
			return bHop;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += bHop.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 2
			reverseOS.write(0x82);
			codeLength += 1;
			
			codeLength += bSRS.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 1
			reverseOS.write(0x81);
			codeLength += 1;
			
			codeLength += cSRS.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 0
			reverseOS.write(0x80);
			codeLength += 1;
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
				cSRS = new BerInteger();
				subCodeLength += cSRS.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
				bSRS = new BerInteger();
				subCodeLength += bSRS.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
				bHop = new BerInteger();
				subCodeLength += bHop.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (cSRS != null) {
				sb.append("cSRS: ").append(cSRS);
			}
			else {
				sb.append("cSRS: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (bSRS != null) {
				sb.append("bSRS: ").append(bSRS);
			}
			else {
				sb.append("bSRS: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (bHop != null) {
				sb.append("bHop: ").append(bHop);
			}
			else {
				sb.append("bHop: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ResourceType implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public byte[] code = null;
		public static class Aperiodic implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			
			public Aperiodic() {
			}

			public Aperiodic(byte[] code) {
				this.code = code;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				if (totalLength == 0) {
					return codeLength;
				}
				subCodeLength += berTag.decode(is);
				return subCodeLength;
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		public static class SemiPersistent implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			private SRSPeriodicityAndOffset periodicityAndOffsetSp = null;
			
			public SemiPersistent() {
			}

			public SemiPersistent(byte[] code) {
				this.code = code;
			}

			public void setPeriodicityAndOffsetSp(SRSPeriodicityAndOffset periodicityAndOffsetSp) {
				this.periodicityAndOffsetSp = periodicityAndOffsetSp;
			}

			public SRSPeriodicityAndOffset getPeriodicityAndOffsetSp() {
				return periodicityAndOffsetSp;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				int sublength;

				sublength = periodicityAndOffsetSp.encode(reverseOS);
				codeLength += sublength;
				codeLength += BerLength.encodeLength(reverseOS, sublength);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
				reverseOS.write(0xA0);
				codeLength += 1;
				
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				subCodeLength += berTag.decode(is);
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
					subCodeLength += length.decode(is);
					periodicityAndOffsetSp = new SRSPeriodicityAndOffset();
					subCodeLength += periodicityAndOffsetSp.decode(is, null);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
				}
				throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

				
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				sb.append("\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (periodicityAndOffsetSp != null) {
					sb.append("periodicityAndOffsetSp: ");
					periodicityAndOffsetSp.appendAsString(sb, indentLevel + 1);
				}
				else {
					sb.append("periodicityAndOffsetSp: <empty-required-field>");
				}
				
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		public static class Periodic implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

			public byte[] code = null;
			private SRSPeriodicityAndOffset periodicityAndOffsetP = null;
			
			public Periodic() {
			}

			public Periodic(byte[] code) {
				this.code = code;
			}

			public void setPeriodicityAndOffsetP(SRSPeriodicityAndOffset periodicityAndOffsetP) {
				this.periodicityAndOffsetP = periodicityAndOffsetP;
			}

			public SRSPeriodicityAndOffset getPeriodicityAndOffsetP() {
				return periodicityAndOffsetP;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				int sublength;

				sublength = periodicityAndOffsetP.encode(reverseOS);
				codeLength += sublength;
				codeLength += BerLength.encodeLength(reverseOS, sublength);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
				reverseOS.write(0xA0);
				codeLength += 1;
				
				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;

			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				BerTag berTag = new BerTag();

				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);

				int totalLength = length.val;
				codeLength += totalLength;

				subCodeLength += berTag.decode(is);
				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
					subCodeLength += length.decode(is);
					periodicityAndOffsetP = new SRSPeriodicityAndOffset();
					subCodeLength += periodicityAndOffsetP.decode(is, null);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
				}
				throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

				
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{");
				sb.append("\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (periodicityAndOffsetP != null) {
					sb.append("periodicityAndOffsetP: ");
					periodicityAndOffsetP.appendAsString(sb, indentLevel + 1);
				}
				else {
					sb.append("periodicityAndOffsetP: <empty-required-field>");
				}
				
				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		private Aperiodic aperiodic = null;
		private SemiPersistent semiPersistent = null;
		private Periodic periodic = null;
		
		public ResourceType() {
		}

		public ResourceType(byte[] code) {
			this.code = code;
		}

		public void setAperiodic(Aperiodic aperiodic) {
			this.aperiodic = aperiodic;
		}

		public Aperiodic getAperiodic() {
			return aperiodic;
		}

		public void setSemiPersistent(SemiPersistent semiPersistent) {
			this.semiPersistent = semiPersistent;
		}

		public SemiPersistent getSemiPersistent() {
			return semiPersistent;
		}

		public void setPeriodic(Periodic periodic) {
			this.periodic = periodic;
		}

		public Periodic getPeriodic() {
			return periodic;
		}

		public int encode(OutputStream reverseOS) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				return code.length;
			}

			int codeLength = 0;
			if (periodic != null) {
				codeLength += periodic.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 2
				reverseOS.write(0xA2);
				codeLength += 1;
				return codeLength;
			}
			
			if (semiPersistent != null) {
				codeLength += semiPersistent.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
				reverseOS.write(0xA1);
				codeLength += 1;
				return codeLength;
			}
			
			if (aperiodic != null) {
				codeLength += aperiodic.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
				reverseOS.write(0xA0);
				codeLength += 1;
				return codeLength;
			}
			
			throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
		}

		public int decode(InputStream is) throws IOException {
			return decode(is, null);
		}

		public int decode(InputStream is, BerTag berTag) throws IOException {

			int codeLength = 0;
			BerTag passedTag = berTag;

			if (berTag == null) {
				berTag = new BerTag();
				codeLength += berTag.decode(is);
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
				aperiodic = new Aperiodic();
				codeLength += aperiodic.decode(is, false);
				return codeLength;
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
				semiPersistent = new SemiPersistent();
				codeLength += semiPersistent.decode(is, false);
				return codeLength;
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 2)) {
				periodic = new Periodic();
				codeLength += periodic.decode(is, false);
				return codeLength;
			}

			if (passedTag != null) {
				return 0;
			}

			throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			if (aperiodic != null) {
				sb.append("aperiodic: ");
				aperiodic.appendAsString(sb, indentLevel + 1);
				return;
			}

			if (semiPersistent != null) {
				sb.append("semiPersistent: ");
				semiPersistent.appendAsString(sb, indentLevel + 1);
				return;
			}

			if (periodic != null) {
				sb.append("periodic: ");
				periodic.appendAsString(sb, indentLevel + 1);
				return;
			}

			sb.append("<none>");
		}

	}

	public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

	public byte[] code = null;
	private SRSResourceId srsResourceId = null;
	private BerEnum nrofSRSPorts = null;
	private BerEnum ptrsPortIndex = null;
	private TransmissionComb transmissionComb = null;
	private ResourceMapping resourceMapping = null;
	private BerInteger freqDomainPosition = null;
	private BerInteger freqDomainShift = null;
	private FreqHopping freqHopping = null;
	private BerEnum groupOrSequenceHopping = null;
	private ResourceType resourceType = null;
	private BerBitString sequenceId = null;
	private SRSSpatialRelationInfo spatialRelationInfo = null;
	
	public SRSResource() {
	}

	public SRSResource(byte[] code) {
		this.code = code;
	}

	public void setSrsResourceId(SRSResourceId srsResourceId) {
		this.srsResourceId = srsResourceId;
	}

	public SRSResourceId getSrsResourceId() {
		return srsResourceId;
	}

	public void setNrofSRSPorts(BerEnum nrofSRSPorts) {
		this.nrofSRSPorts = nrofSRSPorts;
	}

	public BerEnum getNrofSRSPorts() {
		return nrofSRSPorts;
	}

	public void setPtrsPortIndex(BerEnum ptrsPortIndex) {
		this.ptrsPortIndex = ptrsPortIndex;
	}

	public BerEnum getPtrsPortIndex() {
		return ptrsPortIndex;
	}

	public void setTransmissionComb(TransmissionComb transmissionComb) {
		this.transmissionComb = transmissionComb;
	}

	public TransmissionComb getTransmissionComb() {
		return transmissionComb;
	}

	public void setResourceMapping(ResourceMapping resourceMapping) {
		this.resourceMapping = resourceMapping;
	}

	public ResourceMapping getResourceMapping() {
		return resourceMapping;
	}

	public void setFreqDomainPosition(BerInteger freqDomainPosition) {
		this.freqDomainPosition = freqDomainPosition;
	}

	public BerInteger getFreqDomainPosition() {
		return freqDomainPosition;
	}

	public void setFreqDomainShift(BerInteger freqDomainShift) {
		this.freqDomainShift = freqDomainShift;
	}

	public BerInteger getFreqDomainShift() {
		return freqDomainShift;
	}

	public void setFreqHopping(FreqHopping freqHopping) {
		this.freqHopping = freqHopping;
	}

	public FreqHopping getFreqHopping() {
		return freqHopping;
	}

	public void setGroupOrSequenceHopping(BerEnum groupOrSequenceHopping) {
		this.groupOrSequenceHopping = groupOrSequenceHopping;
	}

	public BerEnum getGroupOrSequenceHopping() {
		return groupOrSequenceHopping;
	}

	public void setResourceType(ResourceType resourceType) {
		this.resourceType = resourceType;
	}

	public ResourceType getResourceType() {
		return resourceType;
	}

	public void setSequenceId(BerBitString sequenceId) {
		this.sequenceId = sequenceId;
	}

	public BerBitString getSequenceId() {
		return sequenceId;
	}

	public void setSpatialRelationInfo(SRSSpatialRelationInfo spatialRelationInfo) {
		this.spatialRelationInfo = spatialRelationInfo;
	}

	public SRSSpatialRelationInfo getSpatialRelationInfo() {
		return spatialRelationInfo;
	}

	public int encode(OutputStream reverseOS) throws IOException {
		return encode(reverseOS, true);
	}

	public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

		if (code != null) {
			for (int i = code.length - 1; i >= 0; i--) {
				reverseOS.write(code[i]);
			}
			if (withTag) {
				return tag.encode(reverseOS) + code.length;
			}
			return code.length;
		}

		int codeLength = 0;
		int sublength;

		if (spatialRelationInfo != null) {
			codeLength += spatialRelationInfo.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 11
			reverseOS.write(0xAB);
			codeLength += 1;
		}
		
		codeLength += sequenceId.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 10
		reverseOS.write(0x8A);
		codeLength += 1;
		
		sublength = resourceType.encode(reverseOS);
		codeLength += sublength;
		codeLength += BerLength.encodeLength(reverseOS, sublength);
		// write tag: CONTEXT_CLASS, CONSTRUCTED, 9
		reverseOS.write(0xA9);
		codeLength += 1;
		
		codeLength += groupOrSequenceHopping.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 8
		reverseOS.write(0x88);
		codeLength += 1;
		
		codeLength += freqHopping.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, CONSTRUCTED, 7
		reverseOS.write(0xA7);
		codeLength += 1;
		
		codeLength += freqDomainShift.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 6
		reverseOS.write(0x86);
		codeLength += 1;
		
		codeLength += freqDomainPosition.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 5
		reverseOS.write(0x85);
		codeLength += 1;
		
		codeLength += resourceMapping.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, CONSTRUCTED, 4
		reverseOS.write(0xA4);
		codeLength += 1;
		
		sublength = transmissionComb.encode(reverseOS);
		codeLength += sublength;
		codeLength += BerLength.encodeLength(reverseOS, sublength);
		// write tag: CONTEXT_CLASS, CONSTRUCTED, 3
		reverseOS.write(0xA3);
		codeLength += 1;
		
		if (ptrsPortIndex != null) {
			codeLength += ptrsPortIndex.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 2
			reverseOS.write(0x82);
			codeLength += 1;
		}
		
		codeLength += nrofSRSPorts.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 1
		reverseOS.write(0x81);
		codeLength += 1;
		
		codeLength += srsResourceId.encode(reverseOS, false);
		// write tag: CONTEXT_CLASS, PRIMITIVE, 0
		reverseOS.write(0x80);
		codeLength += 1;
		
		codeLength += BerLength.encodeLength(reverseOS, codeLength);

		if (withTag) {
			codeLength += tag.encode(reverseOS);
		}

		return codeLength;

	}

	public int decode(InputStream is) throws IOException {
		return decode(is, true);
	}

	public int decode(InputStream is, boolean withTag) throws IOException {
		int codeLength = 0;
		int subCodeLength = 0;
		BerTag berTag = new BerTag();

		if (withTag) {
			codeLength += tag.decodeAndCheck(is);
		}

		BerLength length = new BerLength();
		codeLength += length.decode(is);

		int totalLength = length.val;
		codeLength += totalLength;

		subCodeLength += berTag.decode(is);
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
			srsResourceId = new SRSResourceId();
			subCodeLength += srsResourceId.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
			nrofSRSPorts = new BerEnum();
			subCodeLength += nrofSRSPorts.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 2)) {
			ptrsPortIndex = new BerEnum();
			subCodeLength += ptrsPortIndex.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 3)) {
			subCodeLength += length.decode(is);
			transmissionComb = new TransmissionComb();
			subCodeLength += transmissionComb.decode(is, null);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 4)) {
			resourceMapping = new ResourceMapping();
			subCodeLength += resourceMapping.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 5)) {
			freqDomainPosition = new BerInteger();
			subCodeLength += freqDomainPosition.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 6)) {
			freqDomainShift = new BerInteger();
			subCodeLength += freqDomainShift.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 7)) {
			freqHopping = new FreqHopping();
			subCodeLength += freqHopping.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 8)) {
			groupOrSequenceHopping = new BerEnum();
			subCodeLength += groupOrSequenceHopping.decode(is, false);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 9)) {
			subCodeLength += length.decode(is);
			resourceType = new ResourceType();
			subCodeLength += resourceType.decode(is, null);
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 10)) {
			sequenceId = new BerBitString();
			subCodeLength += sequenceId.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			subCodeLength += berTag.decode(is);
		}
		else {
			throw new IOException("Tag does not match the mandatory sequence element tag.");
		}
		
		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 11)) {
			spatialRelationInfo = new SRSSpatialRelationInfo();
			subCodeLength += spatialRelationInfo.decode(is, false);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
		}
		throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

		
	}

	public void encodeAndSave(int encodingSizeGuess) throws IOException {
		ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
		encode(reverseOS, false);
		code = reverseOS.getArray();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		appendAsString(sb, 0);
		return sb.toString();
	}

	public void appendAsString(StringBuilder sb, int indentLevel) {

		sb.append("{");
		sb.append("\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (srsResourceId != null) {
			sb.append("srsResourceId: ").append(srsResourceId);
		}
		else {
			sb.append("srsResourceId: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (nrofSRSPorts != null) {
			sb.append("nrofSRSPorts: ").append(nrofSRSPorts);
		}
		else {
			sb.append("nrofSRSPorts: <empty-required-field>");
		}
		
		if (ptrsPortIndex != null) {
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("ptrsPortIndex: ").append(ptrsPortIndex);
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (transmissionComb != null) {
			sb.append("transmissionComb: ");
			transmissionComb.appendAsString(sb, indentLevel + 1);
		}
		else {
			sb.append("transmissionComb: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (resourceMapping != null) {
			sb.append("resourceMapping: ");
			resourceMapping.appendAsString(sb, indentLevel + 1);
		}
		else {
			sb.append("resourceMapping: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (freqDomainPosition != null) {
			sb.append("freqDomainPosition: ").append(freqDomainPosition);
		}
		else {
			sb.append("freqDomainPosition: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (freqDomainShift != null) {
			sb.append("freqDomainShift: ").append(freqDomainShift);
		}
		else {
			sb.append("freqDomainShift: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (freqHopping != null) {
			sb.append("freqHopping: ");
			freqHopping.appendAsString(sb, indentLevel + 1);
		}
		else {
			sb.append("freqHopping: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (groupOrSequenceHopping != null) {
			sb.append("groupOrSequenceHopping: ").append(groupOrSequenceHopping);
		}
		else {
			sb.append("groupOrSequenceHopping: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (resourceType != null) {
			sb.append("resourceType: ");
			resourceType.appendAsString(sb, indentLevel + 1);
		}
		else {
			sb.append("resourceType: <empty-required-field>");
		}
		
		sb.append(",\n");
		for (int i = 0; i < indentLevel + 1; i++) {
			sb.append("\t");
		}
		if (sequenceId != null) {
			sb.append("sequenceId: ").append(sequenceId);
		}
		else {
			sb.append("sequenceId: <empty-required-field>");
		}
		
		if (spatialRelationInfo != null) {
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			sb.append("spatialRelationInfo: ");
			spatialRelationInfo.appendAsString(sb, indentLevel + 1);
		}
		
		sb.append("\n");
		for (int i = 0; i < indentLevel; i++) {
			sb.append("\t");
		}
		sb.append("}");
	}

}

